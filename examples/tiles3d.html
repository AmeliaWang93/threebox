<!doctype html>
<head>
	<title>TileSet</title>
    <script src="../dist/threebox.js" type="text/javascript"></script>
    <script src="../GLTFLoader.js"></script>
    <script src="../tiles3d.js"></script>
	<script src="config.js"></script>

	<script src='https://api.mapbox.com/mapbox-gl-js/v1.8.1/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v1.8.1/mapbox-gl.css' rel='stylesheet' />
	<style>
		body, html { 
			width: 100%;
			height: 100%;
			margin: 0;
		}
		#map { 
			width: 100%;
			height: 100%;
		}
	</style>
</head>
<body>
	<div id='map' class='map'></div>

	<script>

		if(!config) console.error("Config not set! Make a copy of 'config_template.js', add in your access token, and save the file as 'config.js'.");
		
		mapboxgl.accessToken = config.accessToken;
		var origin = [4.62067229, 52.45920665,0];

		var map = new mapboxgl.Map({
		  container: 'map',
		  style: 'mapbox://styles/mapbox/light-v9',
		  center: origin,
		  zoom: 14,
		  pitch: 60,
		  heading: 41
		});

		//generate a spiral line geometry (not essential for understanding this demo)

		var lineGeometry = [];

		map.on('load', function() {

			map.addLayer({
				id: 'custom_layer',
				type: 'custom',
				renderingMode: '3d',
				onAdd: function(map, mbxContext){

					window.tb = new Threebox(
						map, 
						mbxContext,
						{defaultLights: true}
					);
					let directionalLight = new THREE.DirectionalLight(0xffffff);
					directionalLight.position.set(0, -70, 100).normalize();
					tb.scene.add(directionalLight);

					let directionalLight2 = new THREE.DirectionalLight(0x999999);
					directionalLight2.position.set(0, 70, 100).normalize();
					tb.scene.add(directionalLight2);

					var tubeOptions = {
						geometry: lineGeometry,
						radius: 1,
						sides: 8,
						material: 'MeshPhysicalMaterial',
						color:'#00ffff'
					}
                    this.tileSet = new TileSet();
                    this.tileSet.load('https://saturnus.geodan.nl/maquette_nl/data/buildingtiles_velsen_3857/tileset.json', {}).then(()=>{
                        this.tileSet.root.checkLoad();
                        tb.add(this.tileSet.root.totalContent);
                    })
				},
				
				render: function(gl, matrix){
					tb.update();
				}
			});
		});
		let highlighted = [];
		let active = false;
		let greenMaterial = new THREE.MeshPhongMaterial( {
			color: 0xaaffaa, 
			side: THREE.DoubleSide
		});
		let redMaterial = new THREE.MeshPhongMaterial( {
			color: 0x660000, 
			side: THREE.DoubleSide
		});
                    
		map.on('mousemove', function(e){

			// Clear old objects
			highlighted.forEach(function(h) {
				h.material = h.orgmaterial;
			});
			highlighted.length = 0;


			// calculate objects intersecting the picking ray
			var intersect = tb.queryRenderedFeatures(e.point)[0]
			var intersectionExists = typeof intersect == "object"

			// if intersect exists, highlight it
			if (intersect) {
				var nearestObject = intersect.object;
				nearestObject.orgmaterial = nearestObject.material;
				nearestObject.material = greenMaterial;
				highlighted.push(nearestObject)
			}

			// on state change, fire a repaint
			if (active !== intersectionExists) {
				active = intersectionExists;
				tb.repaint();
			}
		});

	</script>
</body>